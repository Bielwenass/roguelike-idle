import { EntityType } from '@data/enums/EntityType';
import { Point } from '@pixi/core';
import { Sprite } from '@pixi/sprite';
import { get2dArray } from '@utils/get2dArray';
import { isEqualPoint } from '@utils/isEqualPoint';

import { basicBfs } from './movement/MovementAlgorithm';
import { DEBUG_VISIBILITY, TILE_SIZE } from '../../constants';
import { textureTile, textureWall } from '../graphics/Graphics';

import type { Actor } from '@type/Actor';
import type { Cell } from '@type/Cell';
import type { PlayBoard } from '@type/PlayBoard';
import type { WorldContainer } from '@type/WorldContainer';

let freeTiles: Point[] = [];
let visibleTiles: Point[] = [];

export function getRandomFreeTilePoint(): Point {
  return freeTiles.splice(Math.floor(Math.random() * freeTiles.length), 1)[0] ?? new Point(0, 0);
}

function getEmptyCell(x: number, y:number, isGround: boolean): Cell {
  return {
    isGround,
    entityType: EntityType.None,
    position: new Point(x, y),
    wasSeen: false,
    actor: null,
  } as Cell;
}

function addBorderToProtoBoard(protoBoard: number[][]): number[][] {
  protoBoard.forEach((e) => {
    e.unshift(0);
    e.push(0);
  });

  const height = protoBoard[0].length;

  protoBoard.push(Array(height).fill(0));
  protoBoard.unshift(Array(height).fill(0));

  return protoBoard;
}

// Convert map generated by WFC to playboard
export function convertToBoard(rawProtoBoard: number[][]): PlayBoard {
  const protoBoard = addBorderToProtoBoard(rawProtoBoard);

  const height = protoBoard[0].length;
  const width = protoBoard.length;

  const resultBoard = get2dArray(width, height, {}) as PlayBoard;

  for (let x = 0; x < width; x += 1) {
    for (let y = 0; y < height; y += 1) {
      resultBoard[x][y] = getEmptyCell(x, y, protoBoard[x][y] !== 0);
    }
  }

  freeTiles = resultBoard
    .flat()
    .filter((e) => e.isGround && !e.actor)
    .map((e) => e.position);

  // Select the exit tile
  const exitTilePoint = getRandomFreeTilePoint();
  const exitTile = resultBoard[exitTilePoint.x][exitTilePoint.y];

  exitTile.entityType = EntityType.Exit;

  return resultBoard;
}

export function tileBoard(world: WorldContainer) {
  for (const [x, cellRow] of world.board.entries()) {
    for (const [y, cell] of cellRow.entries()) {
      let newTileSprite;

      if (cell.isGround) {
        newTileSprite = new Sprite(textureTile);
      } else {
        newTileSprite = new Sprite(textureWall);
      }

      newTileSprite.width = TILE_SIZE;
      newTileSprite.height = TILE_SIZE;

      const newTile = world.addChild(newTileSprite);

      newTile.x = x * TILE_SIZE;
      newTile.y = y * TILE_SIZE;

      newTile.visible = false;
      cell.sprite = newTile;
    }
  }
}

export function isPointVisible(point: Point) {
  return visibleTiles.some((e) => isEqualPoint(e, point));
}

// Update tiles visibility
export function updateTilesVisibility(player: Actor, playBoard: PlayBoard): PlayBoard {
  if (DEBUG_VISIBILITY) {
    visibleTiles = playBoard.flat().map((e) => e.position);
  } else {
    visibleTiles = basicBfs(playBoard, player.position, player.sightRange);
  }

  return playBoard.map((e) => e.map((cell) => {
    if (isPointVisible(cell.position)) {
      cell.wasSeen = true;
      cell.sprite.visible = true;
      cell.sprite.alpha = 1;
    } else if (cell.wasSeen) {
      cell.sprite.alpha = 0.5;
    } else {
      cell.sprite.visible = false;
    }

    return cell;
  }));
}
